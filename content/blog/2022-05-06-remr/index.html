---
title: 'remr'
layout: single-sidebar
date: '2022-05-06'
categories:
  - R
  - Hydrology
subtitle: 'what the heck?! yes, remr. relative elevation model...'
summary: 'Taking a look at the {remr} and how one might use it for art or analysis.'
authors: []
lastmod: ''
featured: yes
output:
  blogdown::html_page:
    css: "style.css"
    toc: true
    toc_depth: 3
    self_contained: false
image:
  caption: '[Image credit: Josh Erickson](featured.png)'
  placement: 2
  focal_point: 'Center'
  preview_only: no
---

  <link rel="stylesheet" href="style.css" type="text/css" />

<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#dem">DEM</a></li>
<li><a href="#remr">remr</a></li>
<li><a href="#so-what">So what?</a></li>
<li><a href="#interpolation">Interpolation</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>I wanted to do a quick dive into the <a href="https://github.com/joshualerickson/remr">{remr}</a> and show how to create Relative Elevation Models (REM) relatively easy in R. You might be asking, ‚Äòwhat the heck is a REM?‚Äô An REM is a way to get elevations relative to a specific elevation. For example, you might want to see whether elevations further away from a point are relatively lower or higher. One way to do this is create transects (linestrings) at a certain angle from the point of interest (cross-section method) or use an interpolation method (IDW, KNN, etc) to relate elevations. This can help with river restoration and design (<a href="https://onlinelibrary.wiley.com/doi/pdf/10.1002/rra.3378">Powers et al.¬†2019</a>), flood prone areas and research, and of course fun art stuff ü§£. Highly recommended, Dan Coe has some great tutorials on REM in QGIS with step by step instructions, find <a href="https://dancoecarto.com/tutorials">here</a>.</p>
</div>
<div id="dem" class="section level2">
<h2>DEM</h2>
<p>A big part of a REM is the elevation grid. There are plenty of ways to get elevation grids in R but for reproducibility I‚Äôm going to use the <a href="https://github.com/jhollist/elevatr">{elevatr}</a>. We need to find an AOI (area of interest) and then we can call the <code>get_elev_raster()</code> function.</p>
<pre class="r"><code>#load libraries we&#39;ll need
library(terra)
library(elevatr)
library(remr)
library(sf)
library(mapedit)
library(mapview)
library(leaflet)
library(stars)
library(gstat)
library(tidyverse)</code></pre>
<p>A quick way to do this is by using <a href="https://github.com/r-spatial/mapedit">{mapedit}</a>. We‚Äôll find an AOI and then draw a box. This is what we‚Äôll use in {elevatr}. Again, you can use your own bbox, spatial object, etc but for ease we‚Äôll draw.</p>
<pre class="r"><code>aoi &lt;- drawFeatures()</code></pre>
<br>
<center>
<p><img src='inst/www/draw.gif' class = 'center'></p>
</center>
<p><br></p>
<p>Once you have an AOI, you can then call the {elevatr} function <code>get_elev_raster()</code> to get a DEM. To make it easier to work with an REM we‚Äôll need to convert our raster to meters projection instead of degrees. Also, the <code>z</code> argument is indicative of the zoom (higher meaning better resolution) and <code>clip</code> helps decide how to clip the DEM.</p>
<pre class="r"><code># convert aoi to utm proj.
aoi_proj &lt;- aoi %&gt;% st_transform(crs = &#39;+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs&#39;)

# get elevation raster (DEM) with utm proj.
ele &lt;- get_elev_raster(locations = aoi_proj,
                       z = 13,
                       prj = &#39;+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs&#39;,
                       clip = &#39;bbox&#39;)</code></pre>
<p>Now that we have a DEM we need to figure out what points we want to relate to. When using {remr}, the function needs a linestring. Why linestring? Well, it‚Äôs easier to create a final grid (REM) but essentially it creates points along the linestring, so‚Ä¶ you could technically use points (maybe in a future release). I like to use one straight linestring (like below) but you could also use multiple linestrings (you would need to run lapply() or map() though on each feature). So let‚Äôs draw a linestring on our DEM.</p>
<pre class="r"><code>line_aoi &lt;- mapview(ele)@map %&gt;%     
            drawFeatures() %&gt;% 
            st_transform(&#39;+proj=utm +zone=52 +datum=WGS84 +units=m +no_defs&#39;)</code></pre>
<p>Ok, before we go on let‚Äôs look at what we have.</p>
<p>We have a DEM and a line that goes through it.Pretty simple, right? From here we want to see what the adjacent elevation is <strong>relative</strong> to the line. This is where we‚Äôll use the {remr}.</p>
</div>
<div id="remr" class="section level2">
<h2>remr</h2>
<p>At a bare minimum, we need to provide a DEM and a line. We also need to know the split on the line (<code>distance</code>) and the length of the transects (<code>length</code>). This is a <strong>cross-section</strong> method and right now is the current method in {remr}. The split will typically be the resolution of the raster input. You can use the code below to get an idea of a distance by using {leafextras} and {maview/leaflet} to get a measurement.</p>
<pre class="r"><code>mapview(list(ele, line_aoi))@map %&gt;% 
  leaflet.extras::addMeasurePathToolbar()</code></pre>
<center>
<img src="inst/www/distance.png" width="370" />
</center>
<div class="b--red ba bw2 ma2 pa4 shadow-1">
<p>This can take a while depending on resolution and size! Also, it‚Äôs a memory eater as well‚Ä¶ I‚Äôd like to have an option to write to disk in the future but for now just be aware.</p>
</div>
<p>Running the <code>get_rem()</code>.</p>
<pre class="r"><code>rem &lt;- get_rem(linestring = line_aoi,
               raster = ele,
               distance = raster::res(ele)[[1]]],
               length = 4000)</code></pre>
<p>The function is getting elevations at each point along the linestring (<code>line_aoi</code>) at a distance as well as along a transect at a 90 degree angle. This gives a grid of points and elevations. Here is a close up below. I just took some random transects to show how it‚Äôs oriented across the linestring but essentially there is one every <em>distance</em> of the input (it would look like a blur if I showed all).</p>
<p><img src="inst/www/unnamed-chunk-10-1.png" width="960" />
We can also see that each point has an elevation associated with it (see below). We now need to subtract these elevations from the main elevation (linestring).</p>
<p><img src="inst/www/unnamed-chunk-11-1.png" width="960" /></p>
<p>This will give us a <strong>relative</strong> elevation!</p>
<pre class="r"><code>rem$rem &lt;- rem$elevation_main - rem$elevation_adj

rem_rast &lt;- terra::rasterize(terra::vect(rem), terra::rast(ele), 
        field = &quot;rem&quot;)

rem_rast &lt;- terra::focal(rem_rast, fun = &#39;mean&#39;, window = 3, na.policy = &#39;only&#39;, na.rm = TRUE )</code></pre>
<p>This will give us a grid of elevations related to the main linestring. Some will be lower (positive) and some higher (negative). This gives us a good idea of where water could theoretically pop up (gaining groundwater reach or overflow surface water). This really helps with visualizing floodplains prior to field observations.</p>
<p><img src="inst/www/unnamed-chunk-13-1.png" width="960" /></p>
<p>But wait. How is this helpful? It just tells us information from the line? Wouldn‚Äôt it be better to just do it along the stream. For sure. Along a stream would be better but it would also overlap (can be done with a consistent angle, i.e.¬†not at 90 for every point). This is where you can take a <strong>regression of choice</strong> and use that instead as your elevation main. So below we‚Äôll use a LOESS function to predict the elevation. What this does is give an arbitrary value to relate to, which will make it easier to see and use for understanding adjacent areas.</p>
<pre class="r"><code>rem_loess &lt;- rem %&gt;% 
  st_drop_geometry() %&gt;% 
  group_by(group) %&gt;% 
  slice(n = 1) %&gt;% 
  na.omit() %&gt;%
  ungroup() %&gt;% 
  mutate(loess = as.numeric(predict(loess(elevation_main~group, data = .)))) %&gt;% select(loess, group) %&gt;% right_join(rem, by = &#39;group&#39;)</code></pre>
<p><img src="inst/www/unnamed-chunk-15-1.png" width="960" /></p>
<p>Now we can redo the the REM with LOESS as our main elevation.</p>
<pre class="r"><code>rem_loess$rem_loess &lt;- rem_loess$loess - rem_loess$elevation_adj

rem_rast_loess &lt;- terra::rasterize(terra::vect(rem_loess), terra::rast(ele), field = &quot;rem_loess&quot;)

rem_rast_loess &lt;- terra::focal(rem_rast_loess, fun = &#39;mean&#39;, window = 3, na.policy = &#39;only&#39;, na.rm = TRUE )</code></pre>
<p>Now let‚Äôs look at the REM. Ahhh, much better! You can see that when you compare side-by-side it‚Äôs not too much of a difference; however, the farther up river you go the more the elevation increases and will make it difficult to see. With a REM, this isn‚Äôt the case since it‚Äôs always relating to the line!</p>
<p><img src="inst/www/unnamed-chunk-17-1.png" width="960" /></p>
</div>
<div id="so-what" class="section level2">
<h2>So what?</h2>
<p>Totally agree. So what, right? We could just use the DEM grid to interpret and check. Yes. There are a lot of different ways to add a <em>relative</em> (the relation you want) linestring. For example, you could collect bankfull heights in the field, terrace heights, thalweg, etc. The REM then relates back to these elevations and gives you an idea of height above or below. With the DEM approach, you are always having to do the math on the fly!</p>
</div>
<div id="interpolation" class="section level2">
<h2>Interpolation</h2>
<p>Another approach is the interpolation method, which as you can imagine ‚Äò<strong>interpolates</strong>‚Äô the elevations near a line. This is great for stream segments in the <a href="https://github.com/USGS-R/nhdplusTools">{nhdplusTools}</a> because of the overlapping that would occur if we used the transect method. Below we‚Äôll look at a stream in the USA (NFK Flathead River) and apply the interpolation method.</p>
<ul>
<li>Get DEM<br />
</li>
<li>Get Stream Segment</li>
<li>Interpolate<br />
</li>
<li>Subtraction</li>
</ul>
<div id="dem-1" class="section level4">
<h4>DEM</h4>
<p>Again we‚Äôll use the {elevatr} package to get the DEM as well as use a meters projection.</p>
<pre class="r"><code>aoi2 &lt;- drawFeatures()</code></pre>
<pre class="r"><code># convert aoi to utm proj.
aoi2_proj &lt;- aoi2 %&gt;% st_transform(crs = &#39;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs&#39;)

# get elevation raster (DEM) with utm proj.
ele2 &lt;- get_elev_raster(locations = aoi2_proj,
                       z = 13,
                       prj = &#39;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs&#39;,
                       clip = &#39;bbox&#39;)</code></pre>
<p>Get the stream segment using <a href="https://github.com/joshualerickson/gwavr">{gwavr}</a> package.</p>
<pre class="r"><code>library(gwavr)

nhd &lt;- get_nldi_interactively() 

nhd_crop &lt;- nhd[[1]]$UM %&gt;% 
            st_transform(&#39;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs&#39;) %&gt;% 
  st_crop(aoi2_proj)</code></pre>
<p><img src="inst/www/unnamed-chunk-21-1.png" width="960" /></p>
<p>Now we can use the <code>st_line_sample()</code> in {sf} to get points along the river.</p>
<pre class="r"><code>points_along_river &lt;- nhd_crop %&gt;% st_cast(.,&#39;LINESTRING&#39;) %&gt;% 
  st_line_sample(., density = terra::res(ele2)[[1]]) %&gt;%    st_as_sf()</code></pre>
<p>From here, we just choose a <strong>interpolator of choice</strong>! We‚Äôll use IDW from the {gstat} package. We‚Äôll extract the elevation from each point and then use that to interpolate onto the elevation grid.</p>
<pre class="r"><code>points_along_river &lt;- points_along_river %&gt;% st_cast(&#39;POINT&#39;) %&gt;% st_as_sf() %&gt;% rename(geometry = &#39;x&#39;) 

points_along_river$ele &lt;- terra::extract(terra::rast(ele2), terra::vect(points_along_river))[,2] 

points_along_river &lt;- points_along_river %&gt;% na.omit()

setup_points &lt;- gstat(formula=ele~1, id = &#39;ele&#39;, data=points_along_river)

## from terra issue 208
fg &lt;- function(model, x, crs, ...) {
     v &lt;- st_as_sf(x, coords=c(&quot;x&quot;, &quot;y&quot;), crs=crs)
     p &lt;- predict(model, v, ...)
     # right now you need to cbind the coordinates; that I can fix
     cbind(x, as.data.frame(p)[,1:2])
}

idw &lt;- terra::interpolate(ele2, setup_points, fun = fg, crs = &#39;+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs&#39;, na.rm = T)</code></pre>
<p>Finally, we‚Äôll just subtract the OG elevation grid from then new interpolated grid to get the REM!</p>
<pre class="r"><code>idwr &lt;- idw-ele2</code></pre>
<p><img src="inst/www/unnamed-chunk-25-1.png" width="960" /></p>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>As you can see there are a couple different ways to do this as well as different ways to apply. I typically just use it to see the confinement of a floodplain and valley. Alright, alright. Mostly just for art :) Hope this helps! Have fun with REMs!</p>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Powers, P. D., Helstab, M., &amp; Niezgoda, S. L. (2019). A process‚Äêbased approach to restoring depositional river valleys to Stage 0, an anastomosing channel network. River Research and Applications, 35(1), 3-13.</p>
</div>
